// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Equinox__StreamId from "./Equinox__StreamId.res.mjs";

var separator = "-";

function validate(raw) {
  if (raw === "") {
    return PervasivesU.failwith("StreamName: Category element must not be empty");
  } else if (raw.includes(separator)) {
    return PervasivesU.failwith("StreamName: Category element \"" + raw + "\" must not contain embedded '-' symbols");
  } else {
    return ;
  }
}

function ofStreamName(x) {
  return x.slice(0, x.indexOf(separator));
}

var Category = {
  separator: separator,
  validate: validate,
  ofStreamName: ofStreamName
};

function tryParse(raw) {
  var idx = raw.indexOf(separator);
  var category = raw.substring(0, idx);
  var id = raw.substring(idx + 1 | 0);
  if (idx < 0 || id === "" || category === "") {
    return ;
  } else {
    return [
            category,
            id
          ];
  }
}

var Internal = {
  tryParse: tryParse
};

function parse(x) {
  var idx = x.indexOf(separator);
  if (idx < 0) {
    PervasivesU.failwith("StreamName \"" + x + "\" must contain a category separator \"" + separator + "\"");
  }
  return x;
}

function create(category, id) {
  validate(category);
  return category + separator + id;
}

function compose(category, elements) {
  return create(category, Equinox__StreamId.Elements.compose(elements));
}

function split(x) {
  var x$1 = tryParse(x);
  if (x$1 !== undefined) {
    return x$1;
  } else {
    return PervasivesU.failwith("StreamName \"" + x + "\" is invalid");
  }
}

function tryMatch(category, dec) {
  return function (x) {
    var match = split(x);
    if (match[0] === category) {
      return Caml_option.some(dec(match[1]));
    }
    
  };
}

function tryFind(cat) {
  return tryMatch(cat, (function (x) {
                return x;
              }));
}

function gen(category, streamId) {
  return function (id) {
    return create(category, streamId(id));
  };
}

function gen2(category, streamId) {
  return function (a, b) {
    return create(category, streamId(a, b));
  };
}

function gen3(category, streamId) {
  return function (a, b, c) {
    return create(category, streamId(a, b, c));
  };
}

function gen4(category, streamId) {
  return function (a, b, c, d) {
    return create(category, streamId(a, b, c, d));
  };
}

var StreamId;

var category = ofStreamName;

export {
  StreamId ,
  Category ,
  category ,
  Internal ,
  parse ,
  create ,
  compose ,
  split ,
  tryMatch ,
  tryFind ,
  gen ,
  gen2 ,
  gen3 ,
  gen4 ,
}
/* No side effect */
