// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Payer from "./Payer.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Invoice from "./Invoice.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as EmailSender from "./EmailSender.res.mjs";
import * as Equinox__Codec from "@equinox-js/rescript/lib/es6/src/Equinox__Codec.res.mjs";
import * as Core from "@equinox-js/core";
import * as Equinox__StreamId from "@equinox-js/rescript/lib/es6/src/Equinox__StreamId.res.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as MessageDb from "@equinox-js/message-db";

var category = "InvoiceAutoEmail";

var streamId = Equinox__StreamId.gen(function (prim) {
      return prim;
    });

var Stream = {
  category: category,
  streamId: streamId
};

function encode(x, param) {
  if (x.TAG === "EmailSent") {
    return [
            "EmailSent",
            JSON.stringify(x._0)
          ];
  } else {
    return [
            "EmailSendingFailed",
            JSON.stringify(x._0)
          ];
  }
}

function tryDecode(x) {
  switch (x[0]) {
    case "EmailSendingFailed" :
        var x$1 = x[1];
        if (x$1 !== undefined) {
          return {
                  TAG: "EmailSendingFailed",
                  _0: JSON.parse(x$1)
                };
        } else {
          return ;
        }
    case "EmailSent" :
        var x$2 = x[1];
        if (x$2 !== undefined) {
          return {
                  TAG: "EmailSent",
                  _0: JSON.parse(x$2)
                };
        } else {
          return ;
        }
    default:
      return ;
  }
}

var codec = Equinox__Codec.json(encode, tryDecode);

var $$Event = {
  encode: encode,
  tryDecode: tryDecode,
  codec: codec
};

function evolve(_state, $$event) {
  return $$event;
}

function fold(state, events) {
  return Belt_Array.reduce(events, state, evolve);
}

var Fold = {
  initial: undefined,
  evolve: evolve,
  fold: fold
};

function sendEmail(service, invoiceId, payerId, amount) {
  var decider = service.resolve(invoiceId);
  return decider.transactAsync(async function (state) {
              if (state !== undefined) {
                return [];
              }
              var payer = await Payer.Service.readProfile(service.payerService, payerId);
              if (payer === undefined) {
                return [{
                          TAG: "EmailSendingFailed",
                          _0: {
                            payer_id: payerId,
                            reason: "Payer not found"
                          }
                        }];
              }
              try {
                await service.sendMail(payer.email, "Invoice", "Please pay " + amount.toString() + " by tuesday");
                return [{
                          TAG: "EmailSent",
                          _0: {
                            email: payer.email,
                            payer_id: payerId
                          }
                        }];
              }
              catch (raw_err){
                var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                if (err.RE_EXN_ID === Js_exn.$$Error) {
                  return [{
                            TAG: "EmailSendingFailed",
                            _0: {
                              payer_id: payerId,
                              reason: Belt_Option.getWithDefault(err._1.message, "unknown error")
                            }
                          }];
                }
                throw err;
              }
            });
}

function inspectState(service, invoiceId) {
  var decider = service.resolve(invoiceId);
  return decider.query(function (s) {
              return s;
            });
}

var Service = {
  sendEmail: sendEmail,
  inspectState: inspectState
};

function resolveCategory(param) {
  return MessageDb.MessageDbCategory.create(param[0], category, codec, fold, undefined, Core.CachingStrategy.Cache(param[1]), MessageDb.AccessStrategy.LatestKnownEvent());
}

function create(config, sendEmail) {
  var payerService = Payer.Config.create(config);
  var sendMail = sendEmail !== undefined ? sendEmail : EmailSender.Memory.sendEmail;
  var category = resolveCategory(config);
  var resolve = function (id) {
    return Core.Decider.forStream(category, streamId(id));
  };
  return {
          payerService: payerService,
          sendMail: sendMail,
          resolve: resolve
        };
}

function decodeFirstEvent(stream, events) {
  var id = Invoice.Stream.tryMatch(stream);
  if (id === undefined) {
    return ;
  }
  var $$event = Invoice.$$Event.codec.tryDecode(Caml_array.get(events, 0));
  if ($$event !== undefined) {
    return [
            Caml_option.valFromOption(id),
            $$event
          ];
  }
  
}

function createHandler(config, sendEmail$1) {
  var service = create(config, sendEmail$1);
  return async function (stream, events) {
    var match = decodeFirstEvent(stream, events);
    if (match === undefined) {
      return ;
    }
    var match$1 = match[1];
    if (typeof match$1 !== "object") {
      return ;
    }
    if (match$1.TAG !== "InvoiceRaised") {
      return ;
    }
    var match$2 = match$1._0;
    return await sendEmail(service, match[0], match$2.payer_id, match$2.amount);
  };
}

var Config = {
  resolveCategory: resolveCategory,
  create: create,
  decodeFirstEvent: decodeFirstEvent,
  createHandler: createHandler
};

export {
  Stream ,
  $$Event ,
  Fold ,
  Service ,
  Config ,
}
/* streamId Not a pure module */
