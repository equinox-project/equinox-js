"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[321],{7522:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(9901);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||a;return n?r.createElement(m,s(s({ref:t},p),{},{components:n})):r.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(7364),o=(n(9901),n(7522));const a={},s="Reactions",i={unversionedId:"core-concepts/reactions",id:"core-concepts/reactions",title:"Reactions",description:"Reactions, in the context of EquinoxJS, are a term that represents responding to changes to event streams. A Decider",source:"@site/docs/core-concepts/reactions.md",sourceDirName:"core-concepts",slug:"/core-concepts/reactions",permalink:"/equinox-js/docs/core-concepts/reactions",draft:!1,editUrl:"https://github.com/nordfjord/equinox-js/tree/main/apps/docs/docs/core-concepts/reactions.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Caching",permalink:"/equinox-js/docs/core-concepts/caching"},next:{title:"Bank Account",permalink:"/equinox-js/docs/examples/bank-account"}},c={},l=[{value:"Example",id:"example",level:2}],p={toc:l},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reactions"},"Reactions"),(0,o.kt)("p",null,'Reactions, in the context of EquinoxJS, are a term that represents responding to changes to event streams. A Decider\nmakes a decision, a Reactor reacts to that decision. You may be familiar with terms like "Projection" and "Process\nManager." These are both valuable concepts, but exist at a higher level than a Reaction, that is all projections are\nreactions, but not all reactions are projections.'),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Imagine you have a group chat with your friends. After posting a message to the group you might expect everyone else\nin the group to be notified. This is a fantastic use of a reaction. We'll start by creating a service for sending the\nnotifications in a consistent manner."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// Decider code omitted\nexport class MessageNotifier {\n  constructor(\n    private readonly pushNotifier: IPushNotifications,\n    private readonly resolve: (messageId: MessageId) => Decider<Event, State>\n  ) {\n  }\n\n  async sendNotifications(messageId: MessageId, message: Message) {\n    const decider = this.resolve(messageId)\n    return decider.transactAsync(async state => {\n      if (state.hasNotified) return [] // already notified\n      try {\n        await this.pushNotifier.sendNotifications({\n          recipients: message.recipients,\n          title: `New message from ${message.sender_name}`\n        })\n        return [{ type: "NotificationsSent" }]\n      } catch (err) {\n        // this is not a critical feature, so we\'re okay with skipping retries and just write down the fact\n        // that we couldn\'t send the notifications for whatever reason\n        return [{ type: "NotificationsFailed", data: { error: err } }]\n      }\n    })\n  }\n}\n')),(0,o.kt)("p",null,"Note the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"decider.transactAsync")," here. In most cases we want to use ",(0,o.kt)("inlineCode",{parentName:"p"},"transact")," in its simplest form but in this\ncase doing that would be very inefficent. Instead we let the notifier decide for itself whether the notification should\nbe sent based on its own current state. This means we'll only attempt to send notifications when we haven't already\ntried before."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: there is still a scenario where a notification is sent twice. If the power goes out between sending the\nnotifications and recording the fact that we did")),(0,o.kt)("p",null,"Now that we have a notifier, we need something to actuate it when a message is sent."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"async function react(streamName: string, events: ITimelineEvent<string>[]) {\n  const [category, streamId] = StreamName.parseCategoryAndId(streamName)\n  if (category !== Message.CATEGORY) return\n  const messageId = MessageId.parse(streamId)\n  // We know that the MessageSent event is always the first event in the stream and as such we do not need to check any other event\n  const ev = Message.codec.tryDecode(events[0]) \n  if (ev.type !== 'MessageSent') return\n  await notifier.sendNotifications(messageId, ev.data)\n}\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"react")," function is responsible for a couple of things. It receives a stream name and a list of events from that stream\nIt then figures out which events we're interested in and then performs actions on those events."),(0,o.kt)("p",null,"The last step is to wire the reaction up to a concrete store"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { MessageDbSource, PgCheckpoints } from "@equinox-js/message-db-consumer"\nimport pg from "pg"\n\nconst checkpointer = new PgCheckpoints(new pg.Pool({ connectionString: "..." }), "public")\nawait checkpointer.ensureTable() // creates the checkpoints table if it doesn\'t exist\n\nconst pool = new pg.Pool({ connectionString: "..." })\n\nconst source = MessageDbSource.create({\n  pool, // the database pool to use\n  batchSize: 500, // under the hood the source polls for baches of events, this controls the batch size\n  categories: [Message.CATEGORY], // list of categories to subscribe to.\n  groupName: "MessageNotifications", // Consumer group name (used for checkpointing and tracing)\n  checkpointer, // the checkpointer maintains checkpoints on per category per group basis\n  // Your handler will receive a list of events for a given stream\n  handler: react,\n  tailSleepIntervalMs: 100, // If we reach the end of the event store, how long should we wait before requesting a new batch?\n  maxConcurrentStreams: 10, // How many streams are we OK to process concurrently?\n})\n\nconst ctrl = new AbortController()\n\nprocess.on(\'SIGINT\', ()=> ctrl.abort())\nprocess.on(\'SIGTERM\', ()=> ctrl.abort())\n\nawait source.start(ctrl.signal)\n')),(0,o.kt)("p",null,"Now we've wired up a reaction!"),(0,o.kt)("h1",{id:"notes"},"Notes"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The only ordering guarantee is within a stream. You might get events across streams in any order"),(0,o.kt)("li",{parentName:"ul"},'The source will "fail fast." Make sure you restart it on failure')))}d.isMDXComponent=!0}}]);