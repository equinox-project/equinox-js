"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[307],{7522:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(9901);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=o,f=p["".concat(c,".").concat(m)]||p[m]||d[m]||a;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8792:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7364),o=(n(9901),n(7522));const a={sidebar_position:1},i="Category",s={unversionedId:"core-concepts/category",id:"core-concepts/category",title:"Category",description:"In event sourcing, a category is a grouping of related streams that share events of the same schema with consistent",source:"@site/docs/core-concepts/category.md",sourceDirName:"core-concepts",slug:"/core-concepts/category",permalink:"/equinox-js/docs/core-concepts/category",draft:!1,editUrl:"https://github.com/nordfjord/equinox-js/tree/main/apps/docs/docs/core-concepts/category.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/equinox-js/docs/intro"},next:{title:"Stream",permalink:"/equinox-js/docs/core-concepts/stream"}},c={},l=[],u={toc:l},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"category"},"Category"),(0,o.kt)("p",null,"In event sourcing, a category is a grouping of related streams that share events of the same schema with consistent\nsemantic meaning. Categories are analogous to classes in object-oriented systems, and play an important role\nin organizing data in any event sourced system."),(0,o.kt)("p",null,"Equinox builds on this conceptual foundation. In addition to sharing event schema and meaning, a category in Equinox\nshares a consistent way to ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29"},(0,o.kt)("inlineCode",{parentName:"a"},"fold"))," events into state,\nand therefore a consistent ",(0,o.kt)("inlineCode",{parentName:"p"},"state"),". The Category abstracts the details of how events are loaded from and written to a\nconcrete store. By buying into the equinox programming model you make it easier to swap out different storage\nimplementations as the needs of your system evolve over time."),(0,o.kt)("h1",{id:"folds-and-state"},"Folds and State"),(0,o.kt)("p",null,'It\'s been said that, in event sourcing, current state is a left fold of previous history, but what does this mean?\nWe\'ve found the most straight forward way to explain this concept is by drawing a parallel with redux. In redux\nyou "dispatch" actions to a store. This action is handled by multiple "reducers" to update the state of the store.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'type Action = { type: "Increment" } | { type: "Decrement" }\ntype State = { count: number }\n\nexport function reducer(state: State = { count: 0 }, action: Action): State {\n  switch (action.type) {\n    case "Increment":\n      return { ...state, count: state.count + 1 }\n    case "Decrement":\n      return { ...state, count: state.count - 1 }\n  }\n  return state\n}\n')),(0,o.kt)("p",null,"One way you can exercise a ",(0,o.kt)("inlineCode",{parentName:"p"},"redux")," reducer is to use ",(0,o.kt)("inlineCode",{parentName:"p"},"Array#reduce")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"[{ type: 'Increment' }, { type: 'Increment' }].reduce(reducer, { count: 0 }) // { count: 2 }\n")),(0,o.kt)("p",null,"In functional languages like OCaml, and F# this concept is not called ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce"),". It's called ",(0,o.kt)("inlineCode",{parentName:"p"},"fold"),". We could\nimplement fold in javascript like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const fold = <Acc, T>(folder: (acc: Acc, value: T) => Acc) => (initial: T, items: T[]) => {\n  let result = initial\n  for (let i = 0; i < items.length; ++i) {\n    result = folder(result, items[i])\n  }\n  return result\n}\n")),(0,o.kt)("p",null,"Notice the type of the ",(0,o.kt)("inlineCode",{parentName:"p"},"folder")," function ",(0,o.kt)("inlineCode",{parentName:"p"},"Acc -> T -> Acc"),', this is exactly the same signature as the reducer function\nabove. Therefore, current state being a left fold of previous history means that we can construct the current state of\nan aggregate by "folding" its events, starting from the beginning (left).'))}d.isMDXComponent=!0}}]);