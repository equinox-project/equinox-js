"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[899],{7522:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(9901);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(n),h=o,f=d["".concat(c,".").concat(h)]||d[h]||u[h]||a;return n?r.createElement(f,s(s({ref:t},p),{},{components:n})):r.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6558:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(7364),o=(n(9901),n(7522));const a={sidebar_position:3},s="Reactions",i={unversionedId:"reactions/index",id:"reactions/index",title:"Reactions",description:"Reactions, in the context of EquinoxJS, are a term that represents responding",source:"@site/docs/reactions/index.md",sourceDirName:"reactions",slug:"/reactions/",permalink:"/equinox-js/docs/reactions/",draft:!1,editUrl:"https://github.com/nordfjord/equinox-js/tree/main/apps/docs/docs/reactions/index.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Identifiers",permalink:"/equinox-js/docs/core-concepts/identifiers"},next:{title:"Considerations",permalink:"/equinox-js/docs/reactions/considerations"}},c={},l=[{value:"Example",id:"example",level:2}],p={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reactions"},"Reactions"),(0,o.kt)("p",null,'Reactions, in the context of EquinoxJS, are a term that represents responding\nto changes to event streams. A Decider makes a decision, a Reactor reacts to\nthat decision. You may be familiar with terms like "Projection" and "Process\nManager." These are both valuable concepts, but exist at a higher level than\na Reaction, that is all projections are reactions, but not all reactions are\nprojections.'),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Imagine you have a group chat with your friends. After posting a message to the\ngroup you might expect everyone else in the group to be notified. This is a\nfantastic use of a reaction. We'll start by creating a service for sending the\nnotifications in a consistent manner."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// Decider code omitted\nexport class MessageNotifier {\n  constructor(\n    private readonly pushNotifier: IPushNotifications,\n    private readonly resolve: (messageId: MessageId) => Decider<Event, State>\n  ) {\n  }\n\n  async sendNotifications(messageId: MessageId, message: Message) {\n    const decider = this.resolve(messageId)\n    return decider.transactAsync(async state => {\n      if (state.hasNotified) return [] // already notified\n      try {\n        await this.pushNotifier.sendNotifications({\n          recipients: message.recipients,\n          title: `New message from ${message.sender_name}`\n        })\n        return [{ type: "NotificationsSent" }]\n      } catch (err) {\n        // this is not a critical feature, so we\'re okay with skipping retries and just write down the fact\n        // that we couldn\'t send the notifications for whatever reason\n        return [{ type: "NotificationsFailed", data: { error: err } }]\n      }\n    })\n  }\n}\n')),(0,o.kt)("p",null,"Note the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"decider.transactAsync")," here. In most cases we want to use\n",(0,o.kt)("inlineCode",{parentName:"p"},"transact")," in its simplest form but in this case doing that would be very\ninefficent. Instead we let the notifier decide for itself whether the\nnotification should be sent based on its own current state. This means we'll\nonly attempt to send notifications when we haven't already tried before."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"IMPORTANT: there is still a change a notification is sent twice. If the\npower goes out between sending the notifications and recording the fact that\nwe did, a double notification can happen")),(0,o.kt)("p",null,"Now that we have a notifier, we need something to actuate it when a message is\nsent."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"async function react(streamName: string, events: ITimelineEvent<string>[]) {\n  const [category, streamId] = StreamName.parseCategoryAndId(streamName)\n  if (category !== Message.CATEGORY) return\n  const messageId = MessageId.parse(streamId)\n  // We know that the MessageSent event is always the first event in the stream \n  // and as such we do not need to check any other event\n  const ev = Message.codec.tryDecode(events[0]) \n  if (ev.type !== 'MessageSent') return\n  await notifier.sendNotifications(messageId, ev.data)\n}\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"react")," function is responsible for a couple of things. It receives a\nstream name and a list of events from that stream. It then figures out which\nevents we're interested in and then performs actions on those events."),(0,o.kt)("p",null,"The last step is to wire the reaction up to a concrete store"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { MessageDbSource, PgCheckpoints } from "@equinox-js/message-db-consumer"\nimport pg from "pg"\n\nconst checkpointer = new PgCheckpoints(new pg.Pool({ connectionString: "..." }), "public")\nawait checkpointer.ensureTable() // creates the checkpoints table if it doesn\'t exist\n\nconst pool = new pg.Pool({ connectionString: "..." })\n\nconst source = MessageDbSource.create({\n  // the database pool to use\n  pool, \n  // under the hood the source polls for baches of events, this controls the batch size\n  batchSize: 500,\n  // list of categories to subscribe to.\n  categories: [Message.CATEGORY], \n  // Consumer group name (used for checkpointing and tracing)\n  groupName: "MessageNotifications", \n  // the checkpointer maintains checkpoints on per category per group basis\n  checkpointer, \n  // Your handler will receive a list of events for a given stream\n  handler: react,\n  // Once we\'ve processed all events in the store, how long should we wait before requesting a new batch?\n  // In this case we want close to real time so will poll after 100ms\n  tailSleepIntervalMs: 100, \n  // How many streams are we OK to process concurrently?\n  maxConcurrentStreams: 10, \n})\n\nconst ctrl = new AbortController()\n\nprocess.on(\'SIGINT\', ()=> ctrl.abort())\nprocess.on(\'SIGTERM\', ()=> ctrl.abort())\n\nawait source.start(ctrl.signal)\n')),(0,o.kt)("p",null,"Now we've wired up a reaction!"))}u.isMDXComponent=!0}}]);