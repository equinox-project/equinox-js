"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[394],{7522:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(9901);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(n),m=r,h=u["".concat(d,".").concat(m)]||u[m]||l[m]||o;return n?a.createElement(h,c(c({ref:t},p),{},{components:n})):a.createElement(h,c({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=m;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:r,c[1]=i;for(var s=2;s<o;s++)c[s]=n[s];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4948:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var a=n(7364),r=(n(9901),n(7522));const o={sidebar_position:4},c="Codec",i={unversionedId:"core-concepts/codec",id:"core-concepts/codec",title:"Codec",description:"It is common in TypeScript applications to use JSON.stringify and JSON.parse",source:"@site/docs/core-concepts/codec.md",sourceDirName:"core-concepts",slug:"/core-concepts/codec",permalink:"/equinox-js/docs/core-concepts/codec",draft:!1,editUrl:"https://github.com/nordfjord/equinox-js/tree/main/apps/docs/docs/core-concepts/codec.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Decider",permalink:"/equinox-js/docs/core-concepts/decider"},next:{title:"Caching",permalink:"/equinox-js/docs/core-concepts/caching"}},d={},s=[],p={toc:s},u="wrapper";function l(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"codec"},"Codec"),(0,r.kt)("p",null,"It is common in TypeScript applications to use ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.stringify")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.parse"),"\nindiscriminately. In the context of event sourced applications this practise has\na couple of problems. Firstly, these APIs are untyped, there's no guarantee that\nwhat you get from the store is what you expected. Secondly, it is common to\nevolve event schemas through upcasting. ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON.parse")," doesn't offer any way to\ndefine the schema you want out or provide default values for missing properties.\nThese deficiencies can lead to unexpected type errors and behaviours."),(0,r.kt)("p",null,"In EquinoxJS codecs as a first class citizen. A naive implementation might look\nlike this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const codec: Codec<Event, Record<string, any>> = {\n  tryDecode(ev): Event | undefined {\n    switch (ev.type) {\n      case "CheckedIn":\n        return { type: ev.type, data: { at: new Date(ev.data.at) } }\n      case "CheckedOut":\n        return { type: ev.type, data: { at: new Date(ev.data.at) } }\n      case "Charged":\n        return { type: ev.type, data: { chargeId: ev.data.chargeId, amount: ev.data.amount, at: new Date(ev.data.at) } }\n      case "Paid":\n        return { type: ev.type, data: { paymentId: ev.data.paymentId, amount: ev.data.amount, at: new Date(ev.data.at) } }\n    }\n  },\n  encode(ev) {\n    return ev\n  },\n}\n')),(0,r.kt)("p",null,"You might decide that this is too naive and that a library like ",(0,r.kt)("inlineCode",{parentName:"p"},"zod")," is called\nfor instead. We happen to expose a utility codec for zod. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const CheckedInSchema = z.object({ at: z.date() })\nconst CheckedOutSchema = z.object({ at: z.date() })\nconst ChargedSchema = z.object({ chargeId: z.string().uuid(), amount: z.number(), at: z.date() })\nconst PaidSchema = z.object({ paymentId: z.string().uuid(), amount: z.number(), at: z.date() })\ntype Event =\n  | { type: "CheckedIn", data: z.infer<typeof CheckedInSchema> }\n  | { type: "CheckedOut", data: z.infer<typeof CheckedOutSchema> }\n  | { type: "Charged", data: z.infer<typeof ChargedSchema> }\n  | { type: "Paid", data: z.infer<typeof PaidSchema> }\n\nconst codec = Codec.zod<Event>({\n  CheckedIn: CheckedInSchema.parse,\n  CheckedOut: CheckedOutSchema.parse,\n  Charged: ChargedSchema.parse,\n  Paid: PaidSchema.parse,\n})\n')),(0,r.kt)("p",null,"Codecs are also where we control the metadata we add onto events. It is common\npractise to record metadata like which user performed the action that led to the\nevent, as well as correlation and causation identifiers. The zod codec accepts a\nsecond argument which transforms the context into metadata."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Context = { correlationId: string, causationId: string, userId: string }\n\nconst contextToMeta = (ctx: Context) => ({\n  // matches ESDB conventions\n  $correlationId: ctx.correlationId,\n  $causationId: ctx.causationId,\n  userId: ctx.userId\n})\n\nconst codec = Codec.zod<Event, Context>({\n  CheckedIn: CheckedInSchema.parse,\n  CheckedOut: CheckedOutSchema.parse,\n  Charged: ChargedSchema.parse,\n  Paid: PaidSchema.parse,\n}, contextToMeta)\n")))}l.isMDXComponent=!0}}]);